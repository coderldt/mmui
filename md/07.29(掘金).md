### 为什么 0.1 + 0.2 !== 0.3
  js的小数在转换二进制存储的时候，会转换为无限循环小数，所以在最终存储的时候会截取一部分，自然通过计算的时候会有稍微的偏差。
### new 一个函数发生了什么
  1. 新建一个对象
  2. 给这个对象的__proto__属性指向 构造函数的元素 prototype属性
  3. 绑定this，执行构造函数
  4. 返回这个这个对象
### 事件流
  事件流包含三个阶段：
    - 事件捕获阶段
    - 目标对象阶段
    - 事件冒泡阶段
### 闭包
  就是返回一个函数，这个函数还保留这父元素作用域链的引入，可以从作用域中找到已经销毁了对象的变量。
### 执行上下文，作用域链
  执行上下文就是在程序即将执行的时候，会创建该函数的执行上下文，其中会包含一些，变量对象，作用域。也可以理解为执当前执行的环境吧。
  作用域表达了，当前你能够访问到那些变量。当在自己作用域找不到变量的时候，就通过作用域链会向上级，父级去寻找，查找，寻找的过程也就是作用域链的改变。
### js的隐式转换和显式转换
  - 1 + true == 2
  - parseInt（）
### this 了解bind apply 和 call的实现
``` js
  Function.prototype.myCall= function (content = window, ...arg) {
    content.fn = this
    const res = content.fn(...arg)
    delete content.fn
    return res
  }

  Function.prototype.myApply = function (content = window, arg) {
    content.fn = this
    const res = content.fn(...arg)
    delete content.fn
    return res
  }

  Function.prototype.myBind = function (content = window, ...arg) {
    content.fn = this
    return function(...arg1) {
      content.fn(...arg, ...arg1)
      delete content.fn
    }
  }
```

### 事件循环机制
  js中分为同步任务和异步任务（宏任务和微任务），主线程执行js代码，遇到同步任务就依次执行，遇到异步任务就放到和合适的任务队列，当主线程的调用栈为空的时候，就去检查微任务是否有执行完毕，当所有微任务执行完毕后去检查宏任务。依次循环便是事件循环机制。

### 手写数组扁平化
