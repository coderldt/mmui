## 垃圾回收机制
  - 标记清除：js会对变量做一个标记yes or no的标签以供js引擎来处理，当变量在某个环境下被使用则标记为yes，当超出改环境（可以理解为超出作用域）则标记为no，然后对有no的标签进行释放。
  - 引用计数：对于js中引用类型的变量, 采用引用计数的内存回收机制,当一个引用类型的变量赋值给另一个变量时, 引用计数会+1, 而当其中有一个变量不再等于值时,引用计数会-1, 如果引用计数为0, 则js引擎会将其释放掉。**（跟踪记录每个值的引用次数，当一个值的引用次数为0的时候，就回收）**

## 设计模式
  - 模板模式： 父类提供基本的方法和模板，子类可以**改写父类的方法**，但是需要调**用父类提供的模板方法进行操作**，
    - 优点：抽离封装公用方案，扩展可变部分，行为有父类控制，子类去实现。
    - 缺点：每个子类需要去实现自己的功能
  - 策略模式：**一个类的行为或其算法可以在运行时更改。**，抽离了一个父类，再父类中进行实例的替换，然后执行新实例的行为。、
  - 工厂模式：工厂模式就是创建对象的一种方式。用来创建多个相似对象，作用就是批量生产。
    - 优点：降低代码的冗余度
  - 单例模式：只会创建一个实例的对象
    - 优点：可以控制实例的数量，节省系统资源
    - 应用：一个班级只有一个班主任、提示弹窗、生成唯一序列号。
  - 观察者模式：当一个对象属性被修改的时候，会自动触发通知他的依赖
  - 发布订阅模式： 当一个对象的属性变化时，会发送一个消息给到他的所有依赖对象
    - 例子： 公众号、$bus、vue响应式功能
  - 装饰器模式：在运行的过程中，在不修改对象前提下，动态扩展这个对象的方法。
    - 优点：更灵活，可以动态的方式扩展对象的功能，可以随时添加，也可以随时废弃
    - 例子：vue-property-decorator 中的@Component就是一个装饰器，在程序编译的时候，执行这个函数，将参数动态处理到你的对象中

[菜鸟](https://www.runoob.com/design-pattern/decorator-pattern.html)
[微信](https://mp.weixin.qq.com/s/n3vsRQZPe0j5oIOk3umj7A)

## webpack面试题
- Vue 命令行界面 (CLI) 围绕 Webpack 创建一个包装器来编译你的 Vue 项目。但是我们为什么要编译它呢？在 Webpack 和 Rollup 这样的打包工具出现之前，我们只需要将我们的 JavaScript 文件部署到服务器并将它们全部包含在一个页面上。当我们的项目很小的时候，这种效果很好。但是**随着技术的发展**，我们开始需要某种程度的打包功能。**单文件组件 (SFC) 和 TypeScript**的使用都需要借助打包工具来构建我们的项目。这就是为什么要引入Vue CLI 。
- **Vue CLI 允许我们在开发和生产期间创建和构建项目。CLI 隐藏了 Webpack 的复杂配置细节**，并在开发和生产过程中为我们的项目提供服务。但是，如果我们想要将它与 Vite 进行比较，那就让我们再深入一点。


## 测试框架

## nuxt.js
  - 含义：是一个基于vuejs的应用框架，最常用的功能是解决spa的ssr问题
  - 特点：框架的路由、异步数据、静态文件服务、集成了后端服务，自动集成vue全家桶，axios，后端。
  - [链接](https://www.nuxtjs.cn/)

## 查看武侯项目介绍

# 前端规范
[链接](https://juejin.cn/post/6996848077340426270)
## git 提交规范插件

## 前端技术选型
  - vue3 官网
    - 公司内有vue3的成品ui库
    - 和甲方沟通，是否有低版本ie兼容的需求
    - 开发组同事都有vue3基础
  - vue2 担保、小贷
    - 项目需求繁杂，开发周期较短，相比vue3，同事更熟悉vue2，可以快速开发。
    - 兼容性方面

## 单点登录实现方案
  - 通过父子域名cookie共享机制，

Vue 命令行界面 (CLI) 围绕 Webpack 创建一个包装器来编译你的 Vue 项目。但是我们为什么要编译它呢？在 Webpack 和 Rollup 这样的打包工具出现之前，我们只需要将我们的 JavaScript 文件部署到服务器并将它们全部包含在一个页面上。当我们的项目很小的时候，这种效果很好。但是随着 Vue 的发展，我们开始需要某种程度的打包功能。单文件组件 (SFC) 和 TypeScript的使用都需要借助打包工具来构建我们的项目。这就是为什么要引入Vue CLI 。
Vue CLI 允许我们在开发和生产期间创建和构建项目。CLI 隐藏了 Webpack 的复杂配置细节，并在开发和生产过程中为我们的项目提供服务。但是，如果我们想要将它与 Vite 进行比较，那就让我们再深入一点。
Webpack
正如 Webpack 网站所描述的，Webpack 是一个静态模块打包工具。但是，这是什么意思？Webpack 的主要目标是获取你的 Web 项目的资产并将它们打包到少量文件中以供浏览器下载。这并不意味着立即加载项目的所有文件，也可以按需下载。
虽然 Webpack 可以打包非代码资产，但它真正的闪光点是打包相关的代码。你可以认为打包就是简单地将所有代码文件（例如JavaScript/TypeScript）合并在一起，但实际上这里还有更多的内容。
Webpack 处理代码中的 imports/require 语句时，只包含实际需要的文件。此外，它经常进行“tree-shaking”，这可以删除实际上从未引用过的代码块（例如类、函数）。通过这种方式，Webpack 可以非常高效地打包你的项目。但是，如果我们正在研究 Vue CLI（包含 Webpack）与 Vite 的比较，我们需要继续看看在开发时会发生什么。
开发过程中的 Webpack
在 Vue CLI 中，Webpack 用于模块绑定。在开发时也会发生这种绑定。当你通过 CLI 开发 Vue 项目时，它会指示 Webpack 以增量方式构建项目并监听更改，以便它可以将更改的文件打包并在浏览器中进行替换。因为构建包是增量的，所以它可以在你开发项目时快速的将更改同步。第一次构建项目时可能会较慢（即 3 秒或更长时间，具体取决于你的项目大小），但一旦项目启动，增量更改的同步会非常快（即 < 1 秒，通常小于 100 毫秒）。
Vite js 是如何工作的？
如果你是Vite的新手，我建议直接从它的创造者尤雨溪那里学习，他在Vue Mastery的课程“使用vite快速构建”中教我们关于Vite的知识。
如果你看过该课程的第一课（它是免费的），你将了解如何开始，但在我们将其与 Vue CLI 和 Webpack 进行比较之前，我们需要了解 Vite 的工作原理。

