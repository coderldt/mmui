## js数据类型
- 基本数据类型: number string boolean null undefined symbol bigint
- 引用数据类型：array object function

## 判断类型
- typeof 可以判断 除 null, array 之外的，所有类型. null 和 undefined 返回object
  - null 以为早期 null 的内存存储地址的问题，导致返回出现问题。
  - array 可以看成一个特殊的对象，key都是有序的数字，底层也是用object来实现的。
- instanceof 判断某个对象是否是某个构造函数的实例
  - **1 instanceof Number 会返回false** 基本数据类型和包装对象类型不同
    - 基本数据类型 let a = 1
    - 包装数据类型 let a = new Number(1)
      - 使用 valueOf 会返回包装数据类型对应的基本数据类型
      - 隐式转换时，会自动转换为基本数据类型 a + 1
  - 自己写一个构造函数
- Array.isArray
- object.prototype.toString.call()
  - 什么情况下会导致返回错误
    - 改写原型链的toString方法
    - 在iframe中使用的，上下文不定的情况下

``` js
  let a = 1
  let b = '1'
  let c = true
  let d = null
  let e = undefined
  let f = []
  let g = {}
  let h = () => {}

  console.log(`a => ${typeof a}`)
  console.log(`b => ${typeof b}`)
  console.log(`c => ${typeof c}`)
  console.log(`d => ${typeof d}`)
  console.log(`e => ${typeof e}`)
  console.log(`f => ${typeof f}`)
  console.log(`g => ${typeof g}`)
  console.log(`h => ${typeof h}`)

  console.log(`a => ${instanceof a}`)
  console.log(`b => ${instanceof b}`)
  console.log(`c => ${instanceof c}`)
  console.log(`d => ${instanceof d}`)
  console.log(`e => ${instanceof e}`)
  console.log(`f => ${instanceof f}`)
  console.log(`g => ${instanceof g}`)
  console.log(`h => ${instanceof h}`)

  const myInstanceof = (object, constructor) => {
    const prototype = constructor.prototype
    const proto = object.__proto__

    while (true) {
      if (prototype === proto) {
        return true
      }

      proto = proto.__proto__
    }

    return false
  }
```


## promise 是用来解决异步变成的一个方法，就是一个包含异步任务的一个容器。
- promise.then 接受两个回调，第一个 promise 成功状态时的回调，第二个 promise 变成 reject 时候的回调
- promise.catch 处理 reject 时候的回调

<!-- 接受多个promise实例组个的一个数组，然后返回了一个promise实例 -->
- promise.all 所有实例都成功，这个 promise 会返回成功，只要有一个失败，这个primise 就返回失败
- promise.race 只要有一个实例状态改变，这个promise就返回那个实例的状态。
- promise.allSettled 所有的实例都相应结束，这个promise会返回一个数组，状态对应参数中的每个promise状态
- promise.any 只要有一个promise变成成功，则这个promise返回成功， 所有的promise返回失败，这个promise才返回失败

## 浏览器的事件循环

## 防抖节流 区别 和 引用场景
- 防抖 在事件触发后，**延迟一定时间执行函数**，如果在延迟时间内**再次触发**事件，则**重新计时**，直到延迟时间内没有再次触发事件，才执行函数。
  - 用户输入的时候，不需要频繁调用接口，只需要在最后一次变动后，调用即可
  - 表单验证，和用户输入类似，和可以提高页面的性能
  - 按钮点击 用户例如在下单的时候，快速频繁点击，只需要调用一次即可
- 节流 规定**在一定时间内，只能执行一次函数**。无论事件触发多么频繁，在规定时间内都只会执行一次函数
  - 页面滚动的时候，例如加载更多数据，广告位置曝光，要控制操作的执行频率，避免频繁计算，而卡顿页面
  - 鼠标移动，类似拖拉拽
  - 自适应界面的实现，也可以控制在一定频率内操作，来提高页面的性能