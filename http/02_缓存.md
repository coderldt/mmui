## 缓存
  - 相关请求头
    - expires（设置资源的过期时间，在时间内则取缓存数据）
    - cache-control：精确控制文件是否去缓存
      - public：浏览器和服务器都可以缓存
      - private：浏览器缓存
      - no-cache：不缓存
      - no-store：不缓存
      - max-age：60 （设置文件的有效时间）
    - last-modified：文件上次资源更新时间，（服务端发送浏览器）
    - if-modified-since：上次资源的更新时间，（浏览器发送给服务端，服务端判断是否采用缓存，返回304，则使用缓存）
### 分类
  - 缓存位置分类
    - memory cache（内存缓存）
      + 一般所有文件都会进入内容缓存，除非设置cache-control: no-store；当tab页面关闭的时候，缓存清除
    - disk cache （磁盘缓存）
      + 大部分的缓存都会进入磁盘缓存，浏览器会根据相应头判断哪些文件会缓存
  - 失效缓存分类
    - 强缓存
    > 通过一些字段（expires，cache-control）固定写死一些时间，在这个时间内，就一直采用缓存，过期的再次发送请求。
      - 一般用于不经常修改的文件数据，或者静态数据；缺点，不能够拿到最新的数据，也不知道是否是最新的。
    - 弱缓存（协商缓存）
      - 通过一些字段动态决定是否采用缓存（eTag，if-none-fetch, if-modified-since，cache-control，last-modified）等等去判断文件的更新时间，以及返回的状态码决定是否采用缓存
        + last-modified or if-modified-since (文件修改时间)
        + eTag or if-none-fetch (文件特殊表示，hash值)

### 过程
  - 第一次服务器发送一个响应报文，携带文件的修改时间（last-modified）
  - 第二次浏览器再次请求这个文件的时候，携带（if-modified-since）也就是上次的值，服务端判断是否修改。相同，一致则304，浏览器采用缓存；不同则返回新的数据，以及修改时间。
  - 结束

### 优点
  - 节省用户流量
  - 加速网站的渲染，提升用户的使用体验
  - 减少服务器的压力，减少读取文件的次数

### 缺点
  - expires 服务端可以随便更改过期时间，导致不准确
  - last-modified只可以精确到秒，其实我觉得还可以